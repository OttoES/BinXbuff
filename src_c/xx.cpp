/* 
  Autogenerated code by OOcodeGenerator
  File name : hh.cpp
  Name      : GGCommsDefinition
  Version   : 1.0.dev1
  Copyright : Copyright OttoES (2018)
 */

#include "hh.hpp

#include <stdio.h>


const int MLEN = 5;

void testfun(void)
{
   ;
} // end test

static uint16_t crc16(uint8_t buf[],int startpos,int endpos) { return 0xEEE; }
// =======================================
// Class MsgHeader implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int MsgHeader::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx)
{
    const int MSG_ID = (const int) (CMD_NONE);
    const int MLEN = (const int) (5);
    const int buffLen = 4+1+1+1+1+2+2+2+2;
          int pos    = 0;
    uint8_t  buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    buff[pos++] = (uint8_t)(__magic);
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(destAddr);
    buff[pos++] = (uint8_t)(sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(msg_id);
    buff[pos++] = (uint8_t)(subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(mlen);
    buff[pos++] = (uint8_t)(mlen>>8);
    buff[pos++] = (uint8_t)(seqNr);
    buff[pos++] = (uint8_t)(seqNr>>8);
    buff[pos++] = (uint8_t)(xxxxx);
    buff[pos++] = (uint8_t)(xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(__crc2);
    buff[pos++] = (uint8_t)(__crc2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int MsgHeader::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    __magic = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  check the field value is equal to the expected value
    if (__magic != 0xEFBE0D90 ) return ERR_VALUE_NOT_EQUAL;
    destAddr = (uint8_t)buff[pos++] ;
    sourceAddr = (uint8_t)buff[pos++] ;
    msg_id = (enum comnd)buff[pos++] ;
    //  this is an assigned value but not verified here
    subCmd = (uint8_t)buff[pos++] ;
    mlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    seqNr = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    xxxxx = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    __crc2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  check the field value is equal to the returned function value
    // call user function with &destAddr and xxxxx&
    const uint16_t ret___crc2 = (const uint16_t) (crc16(buff,4,14));
    if (ret___crc2 != __crc2) return ERR_VALUE_NOT_EQUAL;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

//============== base =================


// This is the base message parser that should be called with
// the byte array to be translated to a spesific message
// First determine the struct/message type based on MSG_ID and
// MSG_COND and then unpack
int objFactory(uint8_t  buff[],int buflen )
{
    int pos = 0;
    uint32_t  __magic = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  check the field value is equal to the expected value
    if (__magic != 0xEFBE0D90 ) return ERR_VALUE_NOT_EQUAL;
    uint8_t  destAddr = (uint8_t)buff[pos++] ;
    uint8_t  sourceAddr = (uint8_t)buff[pos++] ;
    enum comnd  msg_id = (enum comnd)buff[pos++] ;
    //  this is an assigned value but not verified here
    uint8_t  subCmd = (uint8_t)buff[pos++] ;
    uint16_t  mlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    uint16_t  seqNr = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    uint16_t  xxxxx = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    uint16_t  __crc2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  check the field value is equal to the returned function value
    // call user function with &destAddr and xxxxx&
    const uint16_t ret___crc2 = (const uint16_t) (crc16(buff,4,14));
    if (ret___crc2 != __crc2) return ERR_VALUE_NOT_EQUAL;
    
    if (msg_id == CMD_NONE) {    // MsgHeader
      // unpack each field into a variable
      uint32_t  __magic = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
      pos +=4;
      uint8_t  destAddr = (uint8_t)buff[pos++] ;
      uint8_t  sourceAddr = (uint8_t)buff[pos++] ;
      enum comnd  msg_id = (enum comnd)buff[pos++] ;
      uint8_t  subCmd = (uint8_t)buff[pos++] ;
      uint16_t  mlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      uint16_t  seqNr = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      uint16_t  xxxxx = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      uint16_t  __crc2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      if (pos > buflen)    {
        // error
        printf("Message MsgHeader to short");
        return ERR_BUFF_OUT_OF_DATA;
      }
      // call the (external user) defined function with the unpacked data
      PROCESS_MSG_MsgHeader(destAddr,sourceAddr,msg_id,subCmd,mlen,seqNr,xxxxx);
    } else 
    if (msg_id == CMD_READ) {    // ReadMsg
      // unpack each field into a variable
      enum subRead  subCmd2 = (enum subRead)buff[pos++] ;
      uint16_t  rlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      uint16_t  seqNr2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
      pos +=2;
      if (pos > buflen)    {
        // error
        printf("Message ReadMsg to short");
        return ERR_BUFF_OUT_OF_DATA;
      }
      // call the (external user) defined function with the unpacked data
      PROCESS_MSG_ReadMsg(destAddr,sourceAddr,msg_id,subCmd,mlen,seqNr,xxxxx,subCmd2,rlen,seqNr2);
    } else 
    if ((msg_id == CMD_READ_REPLY) && ((subCmd == DINFO_EVENT_LOG)  )) {
      // unpack each field into a variable
      int ii;
      infoLog_t  log[10];
      for (ii = 0; ii < 10 ;ii++) {
        int ret = INFO_LOG_unpack(&log[ii],&buff[pos],buflen-pos);
        if (ret < 0) return ret;
        pos += ret;
      } // for ii
      if (pos > buflen)    {
        // error
        printf("Message ReadMsgReply to short");
        return ERR_BUFF_OUT_OF_DATA;
      }
      // call the (external user) defined function with the unpacked data
      PROCESS_MSG_ReadMsgReply(destAddr,sourceAddr,msg_id,subCmd,mlen,seqNr,xxxxx,log);
    } else 
    if (msg_id == 0x1155) {    // SetProfile
      // unpack each field into a variable
      int32_t  id = (int32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
      pos +=4;
      char  surname[20];
      memcpy(surname,buff+pos,1*20);
      pos += 1*20;
      enum ename  fieldvarname = (enum ename)buff[pos++] ;
      enum Gender  gender = (enum Gender)buff[pos++] ;
      int8_t  dlen = (int8_t)buff[pos++] ;
      char  addit[dlen];
      memcpy(addit,buff+pos,1*dlen);
      pos += 1*dlen;
      if (pos > buflen)    {
        // error
        printf("Message SetProfile to short");
        return ERR_BUFF_OUT_OF_DATA;
      }
      // call the (external user) defined function with the unpacked data
      PROCESS_MSG_SetProfile(destAddr,sourceAddr,msg_id,subCmd,mlen,seqNr,xxxxx,id,surname,fieldvarname,gender,dlen,addit);
    } else 
    {
      // error
      printf("Unknown message tag");
      return ERR_TAG_UNKNOWN;
    }
    return pos;
} // end

// =======================================
// Class ReadMsg implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int ReadMsg::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,enum subRead subCmd2,uint16_t seqNr2)
{
    const int MSG_ID = (const int) (CMD_READ);
    const int MSG_LEN = (const int) (0);
    const int IS_MSG = (const int) (0x55);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 1+2+2;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    buff[pos++] = (uint8_t)(subCmd2);
    //  this is a fixed assigned field
    const uint16_t rlen = (const uint16_t) (0);
    buff[pos++] = (uint8_t)(rlen);
    buff[pos++] = (uint8_t)(rlen>>8);
    buff[pos++] = (uint8_t)(seqNr2);
    buff[pos++] = (uint8_t)(seqNr2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int ReadMsg::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    subCmd2 = (enum subRead)buff[pos++] ;
    rlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    seqNr2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class infoLog implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int infoLog::pack(enum SubCmdRead etype,uint8_t seatNr,uint8_t seatLeftAux1,uint8_t seatRightAux1,uint32_t res)
{
    const int buffLen = 1+1+1+1+4;
          int pos    = 0;
    uint8_t  buff[buffLen];
    buff[pos++] = (uint8_t)(etype);
    buff[pos++] = (uint8_t)(seatNr);
    buff[pos++] = (uint8_t)(seatLeftAux1);
    buff[pos++] = (uint8_t)(seatRightAux1);
    buff[pos++] = (uint8_t)(res);
    buff[pos++] = (uint8_t)(res>>8);
    buff[pos++] = (uint8_t)(res>>16);
    buff[pos++] = (uint8_t)(res>>24);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int infoLog::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    etype = (enum SubCmdRead)buff[pos++] ;
    seatNr = (uint8_t)buff[pos++] ;
    seatLeftAux1 = (uint8_t)buff[pos++] ;
    seatRightAux1 = (uint8_t)buff[pos++] ;
    res = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class ReadMsgReply implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int ReadMsgReply::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,infoLog_t log[])
{
    const int CASE = (const int) (44);
    const int MSG_ID = (const int) (CMD_READ_REPLY);
    const int MSG_COND = (const int) ((subCmd == DINFO_EVENT_LOG)  );
    const int buffLen = 4+1+1+1+1+2+2+2+2+  (10)*-100000;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    int ii;
    for (ii = 0; ii < 10 ;ii++) {
      int ret = ;
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int ReadMsgReply::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    int ii;
    infoLog_t  log[10];
    for (ii = 0; ii < 10 ;ii++) {
      int ret = INFO_LOG_unpack(&log[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class SetProfile implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int SetProfile::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,char surname[],enum ename fieldvarname,enum Gender gender,int8_t dlen,char addit[])
{
    const int MSG_ID = (const int) (0x1155);
    const int ARRLEN = (const int) (10);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 4+ (20)*1+1+1+1+ (dlen)*1;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    //  this is a fixed assigned field
    const int32_t id = (const int32_t) (1);
    buff[pos++] = (uint8_t)(id);
    buff[pos++] = (uint8_t)(id>>8);
    buff[pos++] = (uint8_t)(id>>16);
    buff[pos++] = (uint8_t)(id>>24);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,surname,1*20);
    pos += 1*20;
    buff[pos++] = (uint8_t)(fieldvarname);
    buff[pos++] = (uint8_t)(gender);
    buff[pos++] = (uint8_t)(dlen);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,addit,1*dlen);
    pos += 1*dlen;
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int SetProfile::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    id = (int32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  this is an assigned value but not verified here
    memcpy(surname,buff+pos,1*20);
    pos += 1*20;
    fieldvarname = (enum ename)buff[pos++] ;
    gender = (enum Gender)buff[pos++] ;
    dlen = (int8_t)buff[pos++] ;
    memcpy(addit,buff+pos,1*dlen);
    pos += 1*dlen;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class DemoIntlFuncCall implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int DemoIntlFuncCall::pack(uint16_t vxx1,uint32_t vxx2,infoLog_t infox,uint8_t infoLen,infoLog_t infoarr[])
{
    const int buffLen = 2+4+-100000+1+ (infoLen)*-100000;
          int pos    = 0;
    uint8_t  buff[buffLen];
    buff[pos++] = (uint8_t)(vxx1);
    buff[pos++] = (uint8_t)(vxx1>>8);
    buff[pos++] = (uint8_t)(vxx2);
    buff[pos++] = (uint8_t)(vxx2>>8);
    buff[pos++] = (uint8_t)(vxx2>>16);
    buff[pos++] = (uint8_t)(vxx2>>24);
    { // start block
      int ret = ;
      if (ret < 0) return ret;
      pos += ret;
    } // end block
    buff[pos++] = (uint8_t)(infoLen);
    int ii;
    for (ii = 0; ii < infoLen ;ii++) {
      int ret = ;
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int DemoIntlFuncCall::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    vxx1 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    vxx2 = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    infoLog_t  infox;
    // Read a structured type
    int infox_ret =  unpack(&infox,buff,pos);
    if (infox_ret <0) return infox_ret;
    pos += infox_ret;
    infoLen = (uint8_t)buff[pos++] ;
    int ii;
    infoLog_t  infoarr[infoLen];
    for (ii = 0; ii < infoLen ;ii++) {
      int ret = INFO_LOG_unpack(&infoarr[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

