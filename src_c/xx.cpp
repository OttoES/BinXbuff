/* 
  Autogenerated code by OOcodeGenerator
  File name : hh.cpp
  Name      : GGCommsDefinition
  Version   : 1.0.dev1
  Copyright : Copyright OttoES (2018)
 */

#include "hh.hpp

#include <stdio.h>


const int MLEN = 5;

void testfun(void)
{
   ;
} // end test

static uint16_t crc16(uint8_t buf[],int startpos,int endpos) { return 0xEEE; }
// =======================================
// Class MsgHeader implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int MsgHeader::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx)
{
    const int MSG_ID = (const int) (CMD_NONE);
    const int MLEN = (const int) (5);
    const int buffLen = 4+1+1+1+1+2+2+2+2;
          int pos    = 0;
    uint8_t  buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    buff[pos++] = (uint8_t)(__magic);
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(destAddr);
    buff[pos++] = (uint8_t)(sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(msg_id);
    buff[pos++] = (uint8_t)(subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(mlen);
    buff[pos++] = (uint8_t)(mlen>>8);
    buff[pos++] = (uint8_t)(seqNr);
    buff[pos++] = (uint8_t)(seqNr>>8);
    buff[pos++] = (uint8_t)(xxxxx);
    buff[pos++] = (uint8_t)(xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(__crc2);
    buff[pos++] = (uint8_t)(__crc2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int MsgHeader::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    __magic = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  check the field value is equal to the expected value
    if (__magic != 0xEFBE0D90 ) return ERR_VALUE_NOT_EQUAL;
    destAddr = (uint8_t)buff[pos++] ;
    sourceAddr = (uint8_t)buff[pos++] ;
    msg_id = (enum comnd)buff[pos++] ;
    //  this is an assigned value but not verified here
    subCmd = (uint8_t)buff[pos++] ;
    mlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    seqNr = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    xxxxx = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    __crc2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  check the field value is equal to the returned function value
    // call user function with &destAddr and xxxxx&
    const uint16_t ret___crc2 = (const uint16_t) (crc16(buff,4,14));
    if (ret___crc2 != __crc2) return ERR_VALUE_NOT_EQUAL;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class ReadMsg implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int ReadMsg::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,enum subRead subCmd2,uint16_t seqNr2)
{
    const int MSG_ID = (const int) (CMD_READ);
    const int MSG_LEN = (const int) (0);
    const int IS_MSG = (const int) (0x55);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 1+2+2;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    buff[pos++] = (uint8_t)(subCmd2);
    //  this is a fixed assigned field
    const uint16_t rlen = (const uint16_t) (0);
    buff[pos++] = (uint8_t)(rlen);
    buff[pos++] = (uint8_t)(rlen>>8);
    buff[pos++] = (uint8_t)(seqNr2);
    buff[pos++] = (uint8_t)(seqNr2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int ReadMsg::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    subCmd2 = (enum subRead)buff[pos++] ;
    rlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    seqNr2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class infoLog implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int infoLog::pack(enum SubCmdRead etype,uint8_t seatNr,uint8_t seatLeftAux1,uint8_t seatRightAux1,uint32_t res)
{
    const int buffLen = 1+1+1+1+4;
          int pos    = 0;
    uint8_t  buff[buffLen];
    buff[pos++] = (uint8_t)(etype);
    buff[pos++] = (uint8_t)(seatNr);
    buff[pos++] = (uint8_t)(seatLeftAux1);
    buff[pos++] = (uint8_t)(seatRightAux1);
    buff[pos++] = (uint8_t)(res);
    buff[pos++] = (uint8_t)(res>>8);
    buff[pos++] = (uint8_t)(res>>16);
    buff[pos++] = (uint8_t)(res>>24);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int infoLog::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    etype = (enum SubCmdRead)buff[pos++] ;
    seatNr = (uint8_t)buff[pos++] ;
    seatLeftAux1 = (uint8_t)buff[pos++] ;
    seatRightAux1 = (uint8_t)buff[pos++] ;
    res = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class ReadMsgReply implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int ReadMsgReply::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,infoLog_t log[])
{
    const int CASE = (const int) (44);
    const int MSG_ID = (const int) (CMD_READ_REPLY);
    const int MSG_COND = (const int) ((subCmd == DINFO_EVENT_LOG)  );
    const int buffLen = 4+1+1+1+1+2+2+2+2+  (10)*-100000;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    int ii;
    for (ii = 0; ii < 10 ;ii++) {
      int ret = ;
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int ReadMsgReply::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    int ii;
    infoLog_t  log[10];
    for (ii = 0; ii < 10 ;ii++) {
      int ret = INFO_LOG_unpack(&log[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class SetProfile implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int SetProfile::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,char surname[],enum ename fieldvarname,enum Gender gender,int8_t dlen,char addit[])
{
    const int MSG_ID = (const int) (0x1155);
    const int ARRLEN = (const int) (10);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 4+ (20)*1+1+1+1+ (dlen)*1;
          int pos    = 0;
    uint8_t  buff[buffLen];
    // call parent pack
    pos += MsgHeader::pack(destAddr,sourceAddr,subCmd,seqNr,xxxxx);
    // over write the values changed by this child
    //  this is a fixed assigned field
    const int32_t id = (const int32_t) (1);
    buff[pos++] = (uint8_t)(id);
    buff[pos++] = (uint8_t)(id>>8);
    buff[pos++] = (uint8_t)(id>>16);
    buff[pos++] = (uint8_t)(id>>24);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,surname,1*20);
    pos += 1*20;
    buff[pos++] = (uint8_t)(fieldvarname);
    buff[pos++] = (uint8_t)(gender);
    buff[pos++] = (uint8_t)(dlen);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,addit,1*dlen);
    pos += 1*dlen;
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int SetProfile::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    pos +=  MsgHeader::unpack(buff,buflen);
    id = (int32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  this is an assigned value but not verified here
    memcpy(surname,buff+pos,1*20);
    pos += 1*20;
    fieldvarname = (enum ename)buff[pos++] ;
    gender = (enum Gender)buff[pos++] ;
    dlen = (int8_t)buff[pos++] ;
    memcpy(addit,buff+pos,1*dlen);
    pos += 1*dlen;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class DemoIntlFuncCall implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int DemoIntlFuncCall::pack(uint16_t vxx1,uint32_t vxx2,infoLog_t infox,uint8_t infoLen,infoLog_t infoarr[])
{
    const int buffLen = 2+4+-100000+1+ (infoLen)*-100000;
          int pos    = 0;
    uint8_t  buff[buffLen];
    buff[pos++] = (uint8_t)(vxx1);
    buff[pos++] = (uint8_t)(vxx1>>8);
    buff[pos++] = (uint8_t)(vxx2);
    buff[pos++] = (uint8_t)(vxx2>>8);
    buff[pos++] = (uint8_t)(vxx2>>16);
    buff[pos++] = (uint8_t)(vxx2>>24);
    { // start block
      int ret = ;
      if (ret < 0) return ret;
      pos += ret;
    } // end block
    buff[pos++] = (uint8_t)(infoLen);
    int ii;
    for (ii = 0; ii < infoLen ;ii++) {
      int ret = ;
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int DemoIntlFuncCall::unpack(uint8_t  buff[],int buflen )
{ 
    int pos = 0;
    vxx1 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    vxx2 = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    infoLog_t  infox;
    // Read a structured type
    int infox_ret =  unpack(&infox,buff,pos);
    if (infox_ret <0) return infox_ret;
    pos += infox_ret;
    infoLen = (uint8_t)buff[pos++] ;
    int ii;
    infoLog_t  infoarr[infoLen];
    for (ii = 0; ii < infoLen ;ii++) {
      int ret = INFO_LOG_unpack(&infoarr[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

