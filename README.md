# BinXbuff
While still in its initial phase,the aim of this project is to take a definition file that specifies a message on 
a byte level and translates this into code. 
This tool can generate C, java and python to serialize and deserialize a byte stream of data. The byte stream is 
normally either data that must be stored on a file or serial data, e.g. via RS232 or an RF link.  

The purpose is similar to other tools such as protobuff or flatbuff with the following differences:
- protobuff, etc focus on serialization and deserialization of objects, binXbuff focuses on the byte level definition
- this tool focus on embedded processors with limited memory
- messages are defined on byte level which means that that code can be generated for existing binary protocols 
- the C code generated by this tool will not use the heap (no alloc and free calls)
- the Java and python code is to complement the embedded C code for communicating between the embedded devices and PCs or mobile phones

In addition to the features above, a program that can translate between json and this embedded binary protocol is also in the pipeline.

# Protocol definition

The definition can contain the following elements

## Annotations
Annotations are not stricly part of the definition but mainly used to pass data down to the code generators. Annotations can therefore be used to add information such as copyright, specifying details on code generation, etc 

## BinXbuff Comments  
These are comments that are only relevant to the BinXbuff definition or it can be used to temporarily ignore a part of a definition. These comments start with '#' and end at the end of the line.

e.g.
```
 # this is a comment
```
## Documentation Comments 
Documentation comments  are comments that explain the data stream. These comment follow the C/CPP style comments and can be used by a documentation generator to generate documentation for the protocol.

e.g.
```C
/* 
   This comment explains the message definiton below 
 */
struct msg {
  int16   var;    // this comment goes with the var 
} 
```

## Enumeration
Most protocols have a lot of tags with numeric values that have special meaning. BinXbuff therefore allow the definition of these tags with their assosiated values. (Note that here they are only declared as an unsized value but, when used in a structure, enums are declared with a spesific byte size, e.g. enum16)

e.g.
```C
enum Gender {
    UNKNOWN = 0;    
    MALE    = 1;     // set as male
    FEMLE   = 0x2;   // set as female
    OTHER   = 0x3;   // if a person identifies with a different gender 
}

enum Command {
    RESERVED   = 0;    
    READ_INFO  = 11;     // request info command from the server
    SEND_INFO  = 12;     // server reply tag
}

``` 
## Structure Definitions
The struture definition declares the final byte layout. The definition is similar to the sructure definitions used in C or definition of messages in Protobuff. The main characteristic of these field definitions is that each field in the structure defines exacly how many bytes it occupies. 

## Fields Structure Definitions
A struture consists of multiple fields. Each field is defined in terms a its size, endianess, optional fixed value nd given a user friendly name.
### Basic definition
The simplest definiton consists of a type and a field name.
e.g.
```C
struct msg2 {
  uint32   var2;     
  uint8    var3;     
  enum8    Gender gender;
} 
```

### Constant field value
Field with constant values can be declared as follows:
```C
struct msg3 {
  uint32   __magic     = 0x1234567;     
  enum8    Command cmd = READ_INFO;
  uint8    var4;     
  uint8    var5;     
} 
```
### Structures with common Base (inheretance)
In most cases where we use serialization, the messages share a common header which at least defines the length and a message identifier. This senario can be defined in BinXbuff using a base structure  which the other structures share (inheretance in object orientated termonology). Here is a simple example:
```C
struct msgHeaded {
  enum8    Command msgId;
  uint16           msgLen;
} 

struct msgA headedby msgHeader {
  uint32  data;
}

struct msgB headedby msgHeader {
  uint32          userInfo;
  uint16          userLen;
  enum8    Gender gender;
}

```


### Endianess
All fields are little endian by default. If a value should be big endian it can be annotated with @BE to indicate this:
```C
struct msg4 {
  uint32    var6 @BE;     
} 
```

# Specialize Annotations
Annotations are use to aid in the documentation an code generation. Annotation start with the __@__ symbol. 

If annotations are aimed at a spesific code generator, the generator name will normally be used as a prefix just after the @ symbol, e.g. @c_xxx, @py_xxxx, @doc_xxxx, @cpp_xxx, etc.

## Common Annotations
The following annotations contain usefull information and is used by most generators to document the code. It is suggested that they should always be defined.

```
@name       =  "Define Device Messages"
@version    =  "0.0.1"
@copyright  =  "OttoES (2018)"
```

## Documentation Annotations
These annotation tags are used by the document generator and should be self explanatary.
```
@doc_title  =  "Communications Protocol Definition"
@doc_header =  "BXB definition document"
@doc_intro  =  '''This is the definiton of the message protocol
                  used for bla-bla-bla '''

```

## Language Spesfic Annotations
As mentioned, annotations can be aimed a a spesifc generated language. Some of the annotations can also be aimed only at a spesific structure for a spesific language.

## C spesific Annotations
The C code generator is spesifically aimed at embedded processors with limited memory. 
Furtheremore memory allocation is in general not recommended on embedded processors (with good reason). To support some variations of the code generated the following annotations will change the code generated:

### User Function Called in Pack
By default the pack function will simply pack all bytes in a buffer send as argument. An alternavive is that the pack function allocates the buffer and call a function with the byte buffer using the C annotation , __@c_call_in_pack__, to call a C function (__DATA_store__ in this case) at the end of the pack function. The function have fixed return type and arguents:
```
int  Data_store(uint8_t buff, uin16_t buffLen);
```
It is suggested that the return value indicates the number of bytes consumed when positive and indicates an error if negative but these returns are not checked and it is therefore up to the user how these values are inerpreted. 
e.g.
```
@c_call_in_pack = "DATA_store"

struct DemoIntlFuncCall 
@c_call_in_pack = "DATA_transmit"
{
   uint16    vxx1;
   uint32    vxx2;
}
```

Default pack code generated without __@c_call_in_pack__ annotation:
```C

```

Code generaed with __@c_call_in_pack__ :

```C
int  DEMOINTLFUNCCALL_packMsg(uint16_t vxx1,uint32_t vxx2)
{
    const int  buffLen = 2+4;
          int  pos    = 0;
    uint8_t   buff[buffLen];
    buff[pos++] = (uint8_t)vxx1;
    buff[pos++] = (uint8_t)(vxx1>>8);
    buff[pos++] = (uint8_t)vxx2;
    buff[pos++] = (uint8_t)(vxx2>>8);
    buff[pos++] = (uint8_t)(vxx2>>16);
    buff[pos++] = (uint8_t)(vxx2>>24);
    return  DATA_transmit(buff, pos);
} // end

```
