/* --Autogenerated code--
File name : hh.cpp
Name      : GGCommsDefinition
Version   : 1.0.dev1
Copyright : Copyright OttoES (2018)
 */

#include "hh.hpp

#include <stdio.h>


const int MLEN = 5;

void testfun(void)
{
   ;
} // end test

static uint16_t crc16(uint8_t buf[],int startpos,int endpos) { return 0xEEE; }
// =======================================
// Class MsgHeader implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int MSG_HEADER_MsgHeader::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx)
{
    const int MSG_ID = (const int) (CMD_NONE);
    const int MLEN = (const int) (5);
    const int buffLen = 4+1+1+1+1+2+2+2+2;
          int pos    = 0;
    uint8_t   buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)__magic;
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(this.destAddr);
    buff[pos++] = (uint8_t)(this.sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(this.msg_id);
    buff[pos++] = (uint8_t)(this.subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(this.mlen);
    buff[pos++] = (uint8_t)(this.mlen>>8);
    buff[pos++] = (uint8_t)(this.seqNr);
    buff[pos++] = (uint8_t)(this.seqNr>>8);
    buff[pos++] = (uint8_t)(this.xxxxx);
    buff[pos++] = (uint8_t)(this.xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(this.__crc2);
    buff[pos++] = (uint8_t)(this.__crc2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int MSG_HEADER_MsgHeader::unpack(MsgHeader_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    this->__magic = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  check the field value is equal to the expected value
    if (__magic != 0xEFBE0D90 ) return ERR_VALUE_NOT_EQUAL;
    this->destAddr = (uint8_t)buff[pos++] ;
    this->sourceAddr = (uint8_t)buff[pos++] ;
    this->msg_id = (enum comnd)buff[pos++] ;
    //  this is an assigned value but not verified here
    this->subCmd = (uint8_t)buff[pos++] ;
    this->mlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    this->seqNr = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    this->xxxxx = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    this->__crc2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  check the field value is equal to the returned function value
    // call user function with &destAddr and xxxxx&
    const uint16_t ret___crc2 = (const uint16_t) (crc16(buff,4,14));
    if (ret___crc2 != __crc2) return ERR_VALUE_NOT_EQUAL;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class ReadMsg implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int READ_MSG_ReadMsg::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,enum subRead subCmd2,uint16_t seqNr2)
{
    const int MSG_ID = (const int) (CMD_READ);
    const int MSG_LEN = (const int) (0);
    const int IS_MSG = (const int) (0x55);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 1+2+2;
          int pos    = 0;
    uint8_t   buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)__magic;
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(this.destAddr);
    buff[pos++] = (uint8_t)(this.sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(this.msg_id);
    buff[pos++] = (uint8_t)(this.subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(this.mlen);
    buff[pos++] = (uint8_t)(this.mlen>>8);
    buff[pos++] = (uint8_t)(this.seqNr);
    buff[pos++] = (uint8_t)(this.seqNr>>8);
    buff[pos++] = (uint8_t)(this.xxxxx);
    buff[pos++] = (uint8_t)(this.xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(this.__crc2);
    buff[pos++] = (uint8_t)(this.__crc2>>8);
    buff[pos++] = (uint8_t)(this.subCmd2);
    //  this is a fixed assigned field
    const uint16_t rlen = (const uint16_t) (0);
    buff[pos++] = (uint8_t)(this.rlen);
    buff[pos++] = (uint8_t)(this.rlen>>8);
    buff[pos++] = (uint8_t)(this.seqNr2);
    buff[pos++] = (uint8_t)(this.seqNr2>>8);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int READ_MSG_ReadMsg::unpack(ReadMsg_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    pos +=  READ_MSG_MsgHeader::unpack(buff,pos);
    this->subCmd2 = (enum subRead)buff[pos++] ;
    this->rlen = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    //  this is an assigned value but not verified here
    this->seqNr2 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class infoLog implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int INFO_LOG_infoLog::pack(enum SubCmdRead etype,uint8_t seatNr,uint8_t seatLeftAux1,uint8_t seatRightAux1,uint32_t res)
{
    const int buffLen = 1+1+1+1+4;
          int pos    = 0;
    uint8_t   buff[buffLen];
    buff[pos++] = (uint8_t)(this.etype);
    buff[pos++] = (uint8_t)(this.seatNr);
    buff[pos++] = (uint8_t)(this.seatLeftAux1);
    buff[pos++] = (uint8_t)(this.seatRightAux1);
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)res;
    buff[pos++] = (uint8_t)(res>>8);
    buff[pos++] = (uint8_t)(res>>16);
    buff[pos++] = (uint8_t)(res>>24);
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int INFO_LOG_infoLog::unpack(infoLog_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    this->etype = (enum SubCmdRead)buff[pos++] ;
    this->seatNr = (uint8_t)buff[pos++] ;
    this->seatLeftAux1 = (uint8_t)buff[pos++] ;
    this->seatRightAux1 = (uint8_t)buff[pos++] ;
    this->res = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class ReadMsgReply implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int READ_MSG_REPLY_ReadMsgReply::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,infoLog_t log[])
{
    const int CASE = (const int) (44);
    const int MSG_ID = (const int) (CMD_READ_REPLY);
    const int MSG_COND = (const int) ((subCmd == DINFO_EVENT_LOG)  );
    const int buffLen = 4+1+1+1+1+2+2+2+2+  (10)*-100000;
          int pos    = 0;
    uint8_t   buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)__magic;
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(this.destAddr);
    buff[pos++] = (uint8_t)(this.sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(this.msg_id);
    buff[pos++] = (uint8_t)(this.subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(this.mlen);
    buff[pos++] = (uint8_t)(this.mlen>>8);
    buff[pos++] = (uint8_t)(this.seqNr);
    buff[pos++] = (uint8_t)(this.seqNr>>8);
    buff[pos++] = (uint8_t)(this.xxxxx);
    buff[pos++] = (uint8_t)(this.xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(this.__crc2);
    buff[pos++] = (uint8_t)(this.__crc2>>8);
    int ii;
    for (ii = 0; ii < 10 ;ii++) {
      int ret =  INFO_LOG_packIntoBuffer(&log[ii],&buff[pos],bufSize-pos);
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int READ_MSG_REPLY_ReadMsgReply::unpack(ReadMsgReply_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    pos +=  READ_MSG_REPLY_MsgHeader::unpack(buff,pos);
    int ii;
    infoLog_t  log[10];
    for (ii = 0; ii < 10 ;ii++) {
      int ret = INFO_LOG_unpack(&log[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class SetProfile implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int SET_PROFILE_SetProfile::pack(uint8_t destAddr,uint8_t sourceAddr,uint8_t subCmd,uint16_t seqNr,uint16_t xxxxx,char surname[],enum ename fieldvarname,enum Gender gender,int8_t dlen,char addit[])
{
    const int MSG_ID = (const int) (0x1155);
    const int ARRLEN = (const int) (10);
    const int buffLen = 4+1+1+1+1+2+2+2+2+ 4+ (20)*1+1+1+1+ (dlen)*1;
          int pos    = 0;
    uint8_t   buff[buffLen];
    //  this is a fixed assigned field
    const uint32_t __magic = (const uint32_t) (0xEFBE0D90 );
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)__magic;
    buff[pos++] = (uint8_t)(__magic>>8);
    buff[pos++] = (uint8_t)(__magic>>16);
    buff[pos++] = (uint8_t)(__magic>>24);
    buff[pos++] = (uint8_t)(this.destAddr);
    buff[pos++] = (uint8_t)(this.sourceAddr);
    //  this is a fixed assigned field
    const enum comnd msg_id = (const enum comnd) (MSG_ID);
    buff[pos++] = (uint8_t)(this.msg_id);
    buff[pos++] = (uint8_t)(this.subCmd);
    //  this is a fixed assigned field
    const uint16_t mlen = (const uint16_t) (MLEN);
    buff[pos++] = (uint8_t)(this.mlen);
    buff[pos++] = (uint8_t)(this.mlen>>8);
    buff[pos++] = (uint8_t)(this.seqNr);
    buff[pos++] = (uint8_t)(this.seqNr>>8);
    buff[pos++] = (uint8_t)(this.xxxxx);
    buff[pos++] = (uint8_t)(this.xxxxx>>8);
    // call user function with &destAddr and xxxxx&
    const uint16_t __crc2 = (const uint16_t) (crc16(buff,4,14));
    buff[pos++] = (uint8_t)(this.__crc2);
    buff[pos++] = (uint8_t)(this.__crc2>>8);
    //  this is a fixed assigned field
    const int32_t id = (const int32_t) (1);
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)id;
    buff[pos++] = (uint8_t)(id>>8);
    buff[pos++] = (uint8_t)(id>>16);
    buff[pos++] = (uint8_t)(id>>24);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,surname,1*20);
    pos += 1*20;
    buff[pos++] = (uint8_t)(this.fieldvarname);
    buff[pos++] = (uint8_t)(this.gender);
    buff[pos++] = (uint8_t)(this.dlen);
    // just copy but no valid if endianess differ
    memcpy(buff+pos,addit,1*dlen);
    pos += 1*dlen;
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int SET_PROFILE_SetProfile::unpack(SetProfile_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    pos +=  SET_PROFILE_MsgHeader::unpack(buff,pos);
    this->id = (int32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    //  this is an assigned value but not verified here
    char  surname[20];
    memcpy(surname,buff+pos,1*20);
    this->fieldvarname = (enum ename)buff[pos++] ;
    this->gender = (enum Gender)buff[pos++] ;
    this->dlen = (int8_t)buff[pos++] ;
    char  addit[dlen];
    memcpy(addit,buff+pos,1*dlen);
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

// =======================================
// Class DemoIntlFuncCall implementation
// ---------------------------------------

/* 
 @param buff[]     buffer into which data should be packed 
 @param pos        start position in buffer 
 @return if > 0    position in array of last extracted data
 @return if < 0    error in data stream 
 */
int DEMO_INTL_FUNC_CALL_DemoIntlFuncCall::pack(uint16_t vxx1,uint32_t vxx2,infoLog_t infox,uint8_t infoLen,infoLog_t infoarr[])
{
    const int buffLen = 2+4+-100000+1+ (infoLen)*-100000;
          int pos    = 0;
    uint8_t   buff[buffLen];
    buff[pos++] = (uint8_t)(this.vxx1);
    buff[pos++] = (uint8_t)(this.vxx1>>8);
    //  it is faster to copy byte by byte than calling memcpy()
    buff[pos++] = (uint8_t)vxx2;
    buff[pos++] = (uint8_t)(vxx2>>8);
    buff[pos++] = (uint8_t)(vxx2>>16);
    buff[pos++] = (uint8_t)(vxx2>>24);
    { // start block
      int ret =  INFO_LOG_packIntoBuffer(&infox,&buff[pos],bufSize-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // end block
    buff[pos++] = (uint8_t)(this.infoLen);
    int ii;
    for (ii = 0; ii < infoLen ;ii++) {
      int ret =  INFO_LOG_packIntoBuffer(&infoarr[ii],&buff[pos],bufSize-pos);
      if (ret<0) return ret;
      pos += ret;
    } // for ii
    return  DATA_store(buff, pos);

} // end

/* 
 @param buff[]    buffer with data to be unpacked 
 @param buflen    number of bytes in buff, must be at long enough for complete struct 
 @return if > 0 : position in array of last extracted data
 @return if < 0 : error in data stream (-4: too short, -23: CRC error
 */
int DEMO_INTL_FUNC_CALL_DemoIntlFuncCall::unpack(DemoIntlFuncCall_t* this,uint8_t  buff[],int buflen )
{
    int pos = 0;
    this->vxx1 = (uint16_t)(buff[pos] + (buff[pos+1]<<8));
    pos +=2;
    this->vxx2 = (uint32_t)(buff[pos] + (buff[pos+1]<<8) + (((uint32_t)buff[pos+2])<<16) + (((uint32_t)buff[pos+3])<<24)) ;
    pos +=4;
    infoLog_t  infox;
    // Read a structured type
    int infox_ret =  INFO_LOG_unpack(&infox,buff,pos);
    if (infox_ret <0) return infox_ret;
    pos += infox_ret;
    this->infoLen = (uint8_t)buff[pos++] ;
    int ii;
    infoLog_t  infoarr[infoLen];
    for (ii = 0; ii < infoLen ;ii++) {
      int ret = INFO_LOG_unpack(&infoarr[ii],&buff[pos],buflen-pos);
      if (ret < 0) return ret;
      pos += ret;
    } // for ii
    if ( pos > buflen) return ERR_BUFF_OUT_OF_DATA;
    return  pos;
} // end

